#!/usr/bin/env ruby
#  SubtitleIt
#
#  Created on 2008-9-4.
#  Copyright (c) 2008. All rights reserved.
#
begin
  require 'rubygems'
rescue LoadError
  # no rubygems to load, so we fail silently
end

require 'optparse'
require 'subtitle_it'

include SubtitleIt

OPTIONS = {
  :force    => false,
  :format   => nil,
  :delay    => nil
}
MANDATORY_OPTIONS = %w(  )

parser = OptionParser.new do |opts|
  opts.banner = <<BANNER
SubtitleIt - Convert and create subtitles.

Usage: #{File.basename($0)} [options] file_in [file_out]

Options are:
  -c FORMAT --convert=FORMAT  Format to convert to: yml, srt or sub.
      You don`t need to use this if fileout contains a extension.
  
  -f  --force     Force overwrite.
       
  -d DELAY --delay=DELAY  Fix the delay of the file.
  
  -h  --help      Show this.
  
  -v  --version   Program version.
BANNER
  opts.separator ""

  opts.on("-c", "--convert=FORMAT", String,
          "Format to convert to") { |OPTIONS[:format]| }
          
  opts.on("-d", "--delay=DELAY", Float,
          "Delay to add/remove") { |OPTIONS[:delay]| }
          
  opts.on("-f", "--force", "Force overwrite") { OPTIONS[:force] = true }          
          
  opts.on("-h", "--help",
          "Show this help message.") { puts opts; exit }          
          
  #FIXME: I gave up... I cant acess the version var from here... missing something.
  opts.on("-v", "--version",
          "Show program version") {   puts "SubtitleIt v#{SubtitleIt::VERSION::STRING}"; exit }          
          
  opts.parse!(ARGV)

  if MANDATORY_OPTIONS && MANDATORY_OPTIONS.find { |option| OPTIONS[option.to_sym].nil? }
    puts opts; exit
  end
end

if ARGV.empty?
  puts parser.banner
  exit
end


filein = ARGV[0].split('.')
filein_ext = filein.delete_at(-1)
filein = filein.join('')
fileout, fileout_ext = ARGV[1] ? ARGV[1].split('.') : [filein, filein_ext]

#time spent
t = Time.now

#FIXME: ugly
if %w(3g2 3gp 3gp2 3gpp 60d ajp asf asx avchd avi bik bix box cam dat divx dmf dv dvr-ms evo flc fli flic flv flx gvi gvp h264 m1v m2p m2ts m2v m4e m4v mjp mjpeg mjpg mkv moov mov movhd movie movx mp4 mpe mpeg mpg mpv mpv2 mxf nsv nut ogg ogm omf ps qt ram rm rmvb swf ts vfw vid video viv vivo vob vro wm wmv wmx wrap wvx wx x264 xvid).include?(filein_ext)
 #we got a video! 
 include SubtitleIt
  @down = Subdown.new
  @down.log_in!
  @movie = Movie.new(ARGV[0]) 
  res = @down.search_subtitles(@movie)#.inspect
  puts "Found #{res.length} result#{"s" if res.length > 1}. Choose one:\n"
  res.each_with_index do |r,i| 
    puts "#{i+1}) #{r.info["MovieName"]} / #{r.info["MovieYear"]} - #{r.info["SubFileName"]} Dl count: #{r.info["SubDownloadsCnt"]} Rating: #{r.info["SubRating"]}"
    puts "    Language: #{r.info["SubLanguageID"]} Movie rating: #{r.info["MovieImdbRating"]} CD Count: #{r.info["SubSumCD"]}"
    puts "    Comments: #{r.info["SubAuthorComment"]} \n\n"
  end
  printf "Choose one: "  
  choose = STDIN.gets.to_i
  choose = res[choose + 1]
  puts "Downloading #{choose.info}"
  out = @down.download_subtitle(choose)
  format = choose.format
  @down.log_out!
else
  #we got files
  if File.exists?(ARGV[0]) && ( ARGV[1] || OPTIONS[:format] )
    content = File.open(ARGV[0], 'r')
    if OPTIONS[:delay]
      ARGV[1] ||= ARGV[0] + "_new"
      SubtitleIt.srt_delay(ARGV[0],ARGV[1])  
    else
      puts "Working on file #{filein}..."
      sub = Subtitle.new(content, filein_ext) 
      format = OPTIONS[:format]
      format ||= fileout_ext unless fileout_ext == filein_ext
      out = sub.send :"to_#{format}" 
      #TODO: rescue format not found....
    end 
  else
    format = 'rsb'
    out = <<GEN
- title: #{ARGV[0]}
- authors: FIXME 
- version: FIXME
00:05:26.500 => 00:05:28.500 == worth killing for...
00:06:00.400 => 00:06:03.400 == worth dying for...
00:07:00.300 => 00:07:03.300 == worth going to the hell for...
GEN
  end
end

fout = "#{fileout}.#{format}"

if File.exists?(fout) && !OPTIONS[:force] 
    puts "File exists. #{fout}"
else
  File.open(fout, 'w') {|f| f.write(out) }  
  puts "Done. Wrote: #{fout} in #{Time.now - t}s."
end
